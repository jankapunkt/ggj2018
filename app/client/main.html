<head>
	<title>app</title>
</head>

<body>
<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<a class="navbar-brand" href="#">
				<img alt="Brand" src="./brand.png">
			</a>
		</div>
		<ul class="nav navbar-nav pull-right">
			<li>
				<a class="navbar-link" href="/scores">Highscores</a>
			</li>
		</ul>

	</div>
</nav>
<div class="container">
	<div class="row">
		<div class="col text-center">
			{{#if (state 'isRunning')}}
			<span class="badge">Rescued: {{state 'rescuers'}}</span>
			<span class="badge">
				<i class="fa fa-clock-o"></i> {{state 'timer'}}
			</span>
			{{/if}}
		</div>
	</div>
	<div class="row">
		<div id="canvas-container" class="col"></div>
	</div>
	<script type="text/javascript">


		function collect(rescuer) {
			followers.list.splice(followers.list.indexOf(rescuer), 1);
			const collectedRescuers = state.get('rescuers') + 1;
			if (collectedRescuers >= state.get('maxRescuers')) {
				end(true, 'all rescued');
			} else {
				state.set('rescuers', collectedRescuers);
			}
		}

		//////////////////////////////////////////////////////////////////
		//
		//	GLOBAL VARS
		//////////////////////////////////////////////////////////////////
		let timer;
		let timerId;


		const debug = false;
		const WIDTH = 1000;
		const HEIGHT = 600;

		//////////////////////////////////////////////////////////////////
		//
		//	SINGLETONS
		//
		//////////////////////////////////////////////////////////////////


		const Vec = {
			sub(v1, v2) {
				return createVector(v1.x - v2.x, v1.y - v2.y);
			},
			dist(p, q) {
				return Math.sqrt((q.x - p.x) * (q.x - p.x) + (q.y - p.y) * (q.y - p.y))
			}
		};

		const signals = {
			list: [],
			update(targets) {
				// draw signals
				let i;
				for (i = this.list.length - 1; i >= 0; i--) {
					const signal = this.list[i];
					if (signal.isDead()) {
						console.log("die", signal.type);
						this.list.splice(i, 1);
						continue;
					}
					signal.update();
					if (signal.isTransmitting) {
						for (let target of targets) {
							const result = target.receives(signal);
							if (result && result.type === 'player' && target.type === 'rescuer') {
								collect(target);
								this.list.splice(i, 1);
							}
						}
					}
				}
			},
			draw(debug) {
				for (let signal of signals.list) {
					signal.draw(debug);
				}
			},
			create({posX, posY, dirX, dirY, strength}) {
				this.list.push(new Signal({posX, posY, dirX, dirY, strength}))
			}
		};

		const followers = {
			list: [],
			update() {
				let i;
				for (i = this.list.length - 1; i >= 0; i--) {
					const follower = this.list[i];
					if (follower.isDead()) {
						this.list.splice(i, 1);
					}
					follower.update();
				}
			},
			create({posX, posY, strength, type}) {
				this.list.push(new Follower({posX, posY, strength, type}))
			},
			draw() {
				for (let resc of this.list) {
					resc.draw();
				}
			}
		};

		//////////////////////////////////////////////////////////////////
		//
		//	DYNAMIC CLASSES
		//
		//////////////////////////////////////////////////////////////////

		class SignalEmitter {
			constructor({posX, posY, strength}) {
				this.pos = this.bounds(createVector(posX, posY));
				this.strength = strength;

				this.transmitters = [];
				this.isTransmitting = false;

				this.life = 500;
				this.maxLife = 500;

				this.type = 'emitter';
			}

			lifep() { return parseInt(this.life / this.maxLife * 100, 10); }

			isDead() { return this.life <= 0; }

			bounds(vec) {
				if (vec.x < 0) vec.x = 0;
				if (vec.x > WIDTH) vec.x = WIDTH;
				if (vec.y < 0) vec.y = 0;
				if (vec.y > HEIGHT) vec.y = HEIGHT;
				return vec;
			}

			initTransmission() {
				for (let i = 1; i < 5; i++) {
					this.transmitters.push(createTransmitter({
						pos: this.pos,
						index: i,
						strength: this.strength,
					}))
				}
			}

			transmit(life) {
				if (!this.isTransmitting)
					return;

				// init transmitters
				for (let transm of this.transmitters) {
					transm.update();
					transm.draw(life);
				}
			}
		}

		class Movable extends SignalEmitter {

			constructor({posX, posY, dirX, dirY, strength, speed = 8}) {
				super({posX, posY, strength});
				this.acc = createVector(0, 0);
				this.vel = createVector(0, 0);
				this.dir = this.bounds(createVector(dirX, dirY));
				this.speed = speed;
				this.type = 'movable';
			}

			updateDir(x, y) {
				this.dir.set(x, y);
				this.dir = this.bounds(this.dir);
			}

			move(speed) {
				const dir = Vec.sub(this.dir, this.pos);
				dir.normalize();
				dir.mult(0.5);
				this.acc = dir;

				this.vel.add(this.acc);
				this.vel.limit(speed || this.speed);
				this.pos.add(this.vel);
				this.pos = this.bounds(this.pos);
			}

			hit(x2, y2) {
				const x = this.pos.x;
				const y = this.pos.y;
				const rad = 10;
				return !( x > ( x2 + rad ) || x < (x2 - rad) || y > ( y2 + rad ) || y < (y2 - rad) );
			}
		}

		class Player extends SignalEmitter {
			constructor({posX, posY}) {
				super({posX, posY, strength: 75});
				this.col = 255;
				this.size = 10;
				this.initTransmission();
				this.isTransmitting = true;
				this.type = 'player';
			}

			update() {
				this.transmit();
			}

			draw(debug = false) {
				fill(this.col);
				ellipse(this.pos.x, this.pos.y, this.size);
				textSize(24);
				if (debug) {
					textAlign(CENTER);
					fill(0, 0, 255);
					stroke(0, 0, 0, 0);
					text('P', this.pos.x, this.pos.y - 20);
				}
			}
		}

		class Follower extends Movable {
			constructor({posX, posY, speed, type, size = 10}) {
				super({posX, posY, speed});
				if (type === 'enemy') {
					this.col = [255, 0, 0];
					this.sensor = random(this.size * 3, this.size * 9);
				}
				if (type === 'rescuer') {
					this.col = [0, 0, 255];
					this.initTransmission();
					this.isTransmitting = true;
					this.sensor = random(this.size * 2, this.size * 4);
				}
				this.size = size;
				this.type = type;
				this.sensor = random(this.size * 3, this.size * 9);
				this.isFollowing = false;
			}

			update() {
				if (this.type === 'rescuer') {
					this.transmit(this.lifeÅ);
				}
			}

			receives(signal) {
				const distance = dist(signal.pos.x, signal.pos.y, this.pos.x, this.pos.y)
				let strength;
				if (this.type === 'rescuer') {
					if (distance > signal.strength / 2) {
						return null;
					}
					if (distance < 2 && signal.type === 'player') {
						return signal;
					}
					strength = Math.abs(distance - signal.strength) / 100;
				}
				if (this.type === 'enemy') {
					if (distance > signal.strength) {
						return null;
					}
					if (distance < 2) {
						if (signal.type === 'rescuer')
							end(false, 'all rescuers dead')
						if (signal.type === 'player')
							end(false, 'you have been killed')
					}
					strength = Math.abs(distance - signal.strength) / 250;
				}

				this.notify({
					x: signal.pos.x,
					y: signal.pos.y,
					strength,
				});
			}

			notify({x, y, strength}) {
				this.isFollowing = true;
				this.updateDir(x, y);
				this.move(strength);
			}


			draw() {
				// draw sensor
				//noFill();
				//stroke(this.col);
				//ellipse(this.pos.x, this.pos.y, this.sensor);
				drawGradient(this.pos.x, this.pos.y, this.sensor, this.col[0], this.col[1], this.col[2]);

				if (this.isFollowing && this.dir) {
					stroke(this.col);
					line(this.pos.x, this.pos.y, this.dir.x, this.dir.y);
				}


				noStroke();
				fill(this.col);
				ellipse(this.pos.x, this.pos.y, this.size);

			}
		}

		class Signal extends Movable {
			constructor({posX, posY, dirX, dirY, speed = 4, col = 255, life = 500, size = 5, strength}) {
				super({posX, posY, dirX, dirY, speed});
				this.col = col;
				this.maxLife = life;
				this.life = life;
				this.size = size;
				this.strength = strength;
				this.speed = dist(posX, posY, dirX, dirY) / (strength / 3);
				this.drawTarget = true;
				this.type = 'signal';
			}


			update() {

				if (!this.isTransmitting) {
					if (this.life % 100)
						this.drawTarget = !this.drawTarget;
					this.move();
					this.isTransmitting = this.hit(this.dir.x, this.dir.y);
					if (this.isTransmitting) {
						this.drawTarget = false;
						this.initTransmission();
					}
				} else {
					this.transmit(this.life);
				}

				// always
				this.life--;
			}

			draw(debug = false) {
				// draw actual transmitter
				fill(255 - this.life, this.life, 0, this.col);
				ellipse(this.pos.x, this.pos.y, this.size);

				// draw target
				if (this.drawTarget) {
					fill(255, 255, 255, 0);
					stroke(255);
					ellipse(this.dir.x, this.dir.y, this.size * 3);
				}

				if (debug) {
					stroke(255, 0, 0);
					fill(0, 0, 0, 0)
					ellipse(this.dir.x, this.dir.y, this.strength);
				}


				// draw lifespan
				if (debug) {
					stroke(0);
					fill(255);
					textAlign(CENTER);
					textSize(20);
					text(this.lifep().toString(), this.pos.x, this.pos.y - 20);
				}

			}

		}

		//////////////////////////////////////////////////////////////////
		//
		//	FACTORY FUNCTIONS
		//
		//////////////////////////////////////////////////////////////////


		function createTransmitter({pos, strength, index}) {
			return {
				pos,
				size: strength / index,
				strength: strength,
				index,
				col: 255,
				update() {
					if (this.size > this.strength)
						this.size = 0;
					this.size++;
					this.col = 255 - 255 * (this.size / this.strength);
				},
				draw(life) {
					fill(0, 0, 0, 0);
					if (life)
						stroke(255 - life, life, 0, this.col);
					else
						stroke(this.col);
					ellipse(this.pos.x, this.pos.y, this.size)
				}
			};
		}

		let rescuers = 0, enemies = 0;
		let _strength = 0;
		let setStrength = false;
		let player;

		function mousePressed() {
			if (!isRunning) return;
			if (mouseX < 0 || mouseX > WIDTH) return false;
			setStrength = true;
			return true;
		}

		function mouseReleased() {
			if (!isRunning) return;
		    if (mouseX < 0 || mouseX > WIDTH) return false;
			setStrength = false;
			signals.create({
				posX: player.pos.x,
				posY: player.pos.y,
				dirX: mouseX,
				dirY: mouseY,
				strength: _strength * 10
			});
			_strength = 0;
			return true;
		}

		function drawGradient(x, y, dim, r, g, b) {
			let h = 0;
			for (let rad = dim; rad > 0; --rad) {
				noStroke();
				fill(r, g, b, h);
				ellipse(x, y, rad, rad);
				h = (h + 0.1) % 360;
			}
		}

		function debugui() {
			textSize(12);
			fill(255);
			text('x: ' + mouseX.toString() + ' y: ' + mouseY.toString(), 20, 20);
		}

		function setup() {
			const canvas = createCanvas(WIDTH, HEIGHT);
			canvas.parent('canvas-container');
			cleanupGame();
		}

		function  cleanupGame() {
			signals.list.length = 0;
			timer = 0;
			followers.list.length = 0;
			rescuers = state.get("rescuers");
			enemies = state.get("enemies");
			timer = state.get("timer");
			startScreen = true;
			isRunning = false;
			noLoop();
		}

		function initGame() {
		    console.log("init game");

			rescuers = state.get("rescuers");
			enemies = state.get("enemies");
			timer = state.get("timer");

			player = new Player({posX: random(0, WIDTH), posY: random(0, HEIGHT)});
			signals.list.push(player);

			for (let i = 0; i < rescuers; i++) {
				followers.create({
					type: 'rescuer',
					posX: random(0, WIDTH),
					posY: random(0, HEIGHT)
				})
			}
			for (let i = 0; i < enemies; i++) {
				followers.create({
					type: 'enemy',
					posX: random(0, WIDTH),
					posY: random(0, HEIGHT)
				})
			}
			timerId = setInterval(function () {
				timer--;
				if (timer <= 0) {
					end(false, 'time up');
				}
				state.set('timer', timer)
			}, 1000);

			isRunning = true;
			startScreen = false;
			loop();
		}

		let isRunning = false;
		let startScreen = true;

		function draw() {
			background(0);

			if (startScreen) {
			    fill(255);
				textAlign(CENTER);
				textSize(148);
				text('NEXT LEVEL', WIDTH/2, HEIGHT / 2 - 100);
				textSize(36);
				text("Time: " + timer.toString(), WIDTH / 2, HEIGHT / 2 - 50);
				text("Enemies: " + enemies.toString(), WIDTH / 2, HEIGHT / 2 );
				text("Rescue: " + rescuers.toString(), WIDTH / 2, HEIGHT / 2 + 50);
				text("Click screen to start", WIDTH / 2, HEIGHT / 2 + 150);
			}

			if (!isRunning) return;

			if (setStrength) {
				_strength++;
				if (_strength > 100)
					_strength = 100;
			}

			player.update(followers.list);


			followers.update();
			signals.update(followers.list);

			followers.draw(debug);
			player.draw(debug);
			signals.draw(debug);

			// draw target spot
			stroke(255);
			fill(255, 255, 255, 0);
			ellipse(mouseX, mouseY, _strength * 10);


			// timer
			fill(255);
			noStroke();
			textSize(12);
			text(timer.toString(), WIDTH - 20, 20)

			debugui();
		}

		function mouseClicked() {
		    if (startScreen && !isRunning) {
		        initGame();
			}
		}

		function end(success, message) {
			noLoop();
			isRunning = false;
			clearTimeout(timerId)
			state.set('win', success);
			state.set('winMsg', message);
			$('#end-modal').modal();
		}

	</script>
</div>
<div id="end-modal" class="modal fade" role="dialog">
	<div class="modal-dialog">
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal">&times;</button>
				<h4 class="modal-title {{#if (state 'win')}}text-success{{else}}text-danger{{/if}}">{{state
						'winMsg'}}</h4>
			</div>
			<div class="modal-body">
				{{#if (state 'win')}}
					<p>Great! You should move to the next stage! Continue?</p>
				{{else}}
					<p>C'mon try again! You can do it! :-P</p>
				{{/if}}
			</div>
			<div class="modal-footer">
				{{#if (state 'win')}}
					<button id="retry-level-button" class="btn btn-success">
						Next Stage
					</button>
				{{else}}
					<button id="next-level-button" class="btn btn-primary">
						Try again
					</button>
				{{/if}}
			</div>
		</div>
	</div>
</div>
</body>