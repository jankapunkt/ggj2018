<head>
	<title>app</title>
</head>

<body>
<nav class="navbar navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<a class="navbar-brand" href="#">
				<img alt="Brand" src="./brand.png">
			</a>
		</div>
	</div>
</nav>
<script type="text/javascript">

	const WIDTH = 1000;
	const HEIGHT = 400;

	const Vec = {
		sub(v1, v2) {
			return createVector(v1.x - v2.x, v1.y - v2.y);
		}
	};

	const rescuers = [];

	// base class
	// TODO extend from this
	const Movable = {
		speed: -1,
		pos:null,
		vel: null,
		acc: null,
		dir: null,
		col: -1,
		life: -1,
	};

	createRescuer = function ({pos, speed, reach}) {
		return {
		    pos, speed, reach,
			update(){

			},
			draw() {

			},
		};
	};

	function createTransmitter({pos, strength, index}) {
		return {
			pos,
			size: strength / index,
			strength: strength,
			index,
			update() {
				if (this.size > this.strength)
					this.size = 0;
				this.size++;
			},
			draw() {
				fill(0, 0, 0, 0);
				stroke(255);
				ellipse(this.pos.x, this.pos.y, this.size)
			}
		};
	}

	const signals = {
		list: [],
		update() {
			// draw signals
			let i;
			for (i = this.list.length - 1; i >= 0; i--) {
				const signal = this.list[i];
				if (signal.isDead()) {
					this.list.splice(i, 1);
				}
				signal.update();
				signal.draw();
			}

		},
		create({vPos, vDir, strength = 100}) {
			this.list.push({
				speed: 4,
				pos: createVector(vPos.x, vPos.y),
				vel: createVector(0, 0,),
				acc: createVector(0, 0),
				dir: createVector(vDir.x, vDir.y),
				col: 255,
				life: 1000,
				size: 5,
				transmitters: [],
				strength,
				isTransmitting: false,
				drawTarget: true,
				reached() {
					const x = this.pos.x;
					const y = this.pos.y;
					const x2 = this.dir.x;
					const y2 = this.dir.y;
					const rad = 10;
					return !( x > ( x2 + rad ) || x < (x2 - rad) || y > ( y2 + rad ) || y < (y2 - rad) );
				},
				isDead() { return this.life <= 0; },
				update() {

					if (!this.isTransmitting) {
						this.move();
						this.isTransmitting = this.reached();
						if (this.isTransmitting) {
							this.drawTarget = false;
							this.initTransmission();
						}
					} else {
						this.transmit();
					}

					// always
					this.life--;
				},
				initTransmission() {
					for (let i = 1; i < 5; i++) {
						this.transmitters.push(createTransmitter({
							pos: this.pos,
							index: i,
							strength: this.strength,
						}))
					}
				},
				transmit() {
					// init transmitters
					for (let transm of this.transmitters) {
						transm.update();
					}
				},
				move() {
					if (this.life % 100)
						this.drawTarget = !this.drawTarget;
					const dir = Vec.sub(this.dir, this.pos);
					dir.normalize();
					dir.mult(0.5);
					this.acc = dir;

					this.vel.add(this.acc);
					this.vel.limit(4);
					this.pos.add(this.vel);
				},

				draw() {
					// draw actual transmitter
					fill(this.life);
					ellipse(this.pos.x, this.pos.y, this.size);

					// draw target
					if (this.drawTarget) {
						fill(255, 255, 255, 0);
						stroke(255);
						ellipse(this.dir.x, this.dir.y, this.size * 3);
					}

					// draw transmitters wave
					if (this.isTransmitting) {
						for (let transm of this.transmitters) {
							transm.draw();
						}
					}

					// draw lifespan
					stroke(0);
					fill(255 - this.life, this.life, 0);
					textAlign(CENTER);
					textSize(20);
					text(this.life.toString(), this.pos.x, this.pos.y - 20);
				}
			});
		}
	};

	const player = {
		pos: null,
		col: 255,
		size: 30,
		updateDir(x, y) {
			this.dir.set(x, y);
		},
		draw() {
			// view line
			stroke(this.col);
			fill(255, 255, 255, 0);
			ellipse(mouseX, mouseY, this.size);

			fill(this.col);
			ellipse(this.pos.x, this.pos.y, this.size);
			textSize(24);
			textAlign(CENTER);
			fill(0,0,255);
			stroke(0,0,0,0);
			text('P', this.pos.x, this.pos.y + 9);
		}
	};

	function mouseClicked() {
		signals.create({vPos: player.pos, vDir: player.dir, strength: 100});
	}

	function debugui() {
		textSize(12);
		fill(255);
		text('x: ' + mouseX.toString() + ' y: ' + mouseY.toString(), 20, 20);
	}

	function setup() {
		createCanvas(WIDTH, HEIGHT);
		player.pos = createVector(30, HEIGHT / 2);
		player.dir = createVector(0, 0);
	}

	function draw() {
		background(0);


		// always draw player
		player.updateDir(mouseX, mouseY);
		player.draw();

		signals.update();

		debugui();
	}
</script>
</body>