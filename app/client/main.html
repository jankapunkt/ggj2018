<head>
	<title>app</title>
</head>

<body>
<nav class="navbar navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<a class="navbar-brand" href="#">
				<img alt="Brand" src="./brand.png">
			</a>
		</div>
	</div>
</nav>
<script type="text/javascript">

	//////////////////////////////////////////////////////////////////
	//
	//	GLOBAL VARS
	//
	//////////////////////////////////////////////////////////////////

	const WIDTH = 1000;
	const HEIGHT = 400;

	//////////////////////////////////////////////////////////////////
	//
	//	SINGLETONS
	//
	//////////////////////////////////////////////////////////////////


	const Vec = {
		sub(v1, v2) {
			return createVector(v1.x - v2.x, v1.y - v2.y);
		}
	};

	const signals = {
		list: [],
		update() {
			// draw signals
			let i;
			for (i = this.list.length - 1; i >= 0; i--) {
				const signal = this.list[i];
				if (signal.isDead()) {
					this.list.splice(i, 1);
				}
				signal.update();
				signal.draw();
			}
		},
		create({posX, posY, dirX, dirY, strength}) {
			this.list.push(new Signal({posX, posY, dirX, dirY, strength}))
		}
	};

	const rescuers = {
	  	list: [],
		update() {
			let i;
			for (i = this.list.length - 1; i >= 0; i--) {
				const rescuers = this.list[i];
				if (rescuers.isDead()) {
					this.list.splice(i, 1);
				}
				rescuers.update();
				rescuers.draw();
			}
		}
	};

	//////////////////////////////////////////////////////////////////
	//
	//	DYNAMIC CLASSES
	//
	//////////////////////////////////////////////////////////////////

	class SignalEmitter {
	    constructor({posX, posY, strength}) {
	        this.pos = createVector(posX, posY);
	        this.strength = strength;

	        this.transmitters = [];
			this.isTransmitting = false;
		}

		initTransmission() {
			for (let i = 1; i < 5; i++) {
				this.transmitters.push(createTransmitter({
					pos: this.pos,
					index: i,
					strength: this.strength,
				}))
			}
		}

		transmit() {
	        if (!this.isTransmitting)
	            return;

			// init transmitters
			for (let transm of this.transmitters) {
				transm.update();
				transm.draw();
			}
		}
	}

	class Movable extends SignalEmitter{

		constructor({posX, posY, dirX, dirY,  strength, speed = 4}) {
			super({posX, posY, strength});
			this.acc = createVector(0, 0);
			this.vel = createVector(0, 0);
			this.dir = createVector(dirX, dirY);
			this.speed = speed;
		}

		updateDir(x, y) {
			this.dir.set(x, y);
		}

		move() {
			const dir = Vec.sub(this.dir, this.pos);
			dir.normalize();
			dir.mult(0.5);
			this.acc = dir;

			this.vel.add(this.acc);
			this.vel.limit(this.speed);
			this.pos.add(this.vel);
		}

		hit(x2, y2) {
			const x = this.pos.x;
			const y = this.pos.y;
			const rad = 10;
			return !( x > ( x2 + rad ) || x < (x2 - rad) || y > ( y2 + rad ) || y < (y2 - rad) );
		}
	}

	class Player extends SignalEmitter {
	    constructor({posX, posY}) {
	    	super({posX, posY, strength: 100});
			this.col = 255;
			this.size = 10;
			this.initTransmission();
			this.isTransmitting = true;
		}

		update() {
	        this.transmit();
		}

		draw(debug=false) {
			fill(this.col);
			ellipse(this.pos.x, this.pos.y, this.size);
			textSize(24);
			if (debug){
			    textAlign(CENTER);
				fill(0, 0, 255);
				stroke(0, 0, 0, 0);
				text('P', this.pos.x, this.pos.y - 20);
			}
		}
	}

	class Rescuer extends Movable {
		constructor({posX, posY, speed}) {
			super({posX, posY, speed});
		}
	}

	class Signal extends Movable {
		constructor({posX, posY, dirX, dirY, speed = 4, col = 255, life = 1000, size = 5, strength}) {
			super({posX, posY, dirX, dirY, speed});
			this.col = col;
			this.maxLife = life;
			this.life = life;
			this.size = size;
			this.strength = strength;


			this.drawTarget = true;
			console.log(strength);
		}

		lifep() { return parseInt(this.life / this.maxLife * 100, 10); }

		isDead() { return this.life <= 0; }

		update() {

			if (!this.isTransmitting) {
				if (this.life % 100)
					this.drawTarget = !this.drawTarget;
				this.move();
				this.isTransmitting = this.hit(this.dir.x, this.dir.y);
				if (this.isTransmitting) {
					this.drawTarget = false;
					this.initTransmission();
				}
			} else {
				this.transmit();
			}

			// always
			this.life--;
		}

		draw() {
			// draw actual transmitter
			fill(this.life);
			ellipse(this.pos.x, this.pos.y, this.size);

			// draw target
			if (this.drawTarget) {
				fill(255, 255, 255, 0);
				stroke(255);
				ellipse(this.dir.x, this.dir.y, this.size * 3);
			}


			// draw lifespan
			stroke(0);
			fill(255 - this.life, this.life, 0, 150);
			textAlign(CENTER);
			textSize(20);
			text(this.lifep().toString(), this.pos.x, this.pos.y - 20);
		}

	}

	//////////////////////////////////////////////////////////////////
	//
	//	FACTORY FUNCTIONS
	//
	//////////////////////////////////////////////////////////////////


	function createTransmitter({pos, strength, index}) {
		return {
			pos,
			size: strength / index,
			strength: strength,
			index,
			col:255,
			update() {
				if (this.size > this.strength)
					this.size = 0;
				this.size++;
				this.col = 255 - 255 * (this.size / this.strength);
			},
			draw() {
				fill(0, 0, 0, 0);
				stroke(this.col);
				ellipse(this.pos.x, this.pos.y, this.size)
			}
		};
	}


	let _strength = 0;
	let setStrength = false;
	let player;

	function mousePressed() {
		setStrength = true;
		return true;
	}

	function mouseReleased() {
	    setStrength = false;
		signals.create({posX: player.pos.x, posY: player.pos.y, dirX: mouseX, dirY: mouseY, strength:_strength * 10});
		_strength = 0;
		return true;
	}

	function debugui() {
		textSize(12);
		fill(255);
		text('x: ' + mouseX.toString() + ' y: ' + mouseY.toString(), 20, 20);
	}

	function setup() {
		createCanvas(WIDTH, HEIGHT);
		player = new Player({posX:30, posY: HEIGHT / 2})
	}

	function draw() {
		background(0);

		if (setStrength) {
			_strength++;
			if (_strength > 100)
			    _strength = 100;
		}

		player.update();
		rescuers.update();
		signals.update();


		// draw strength
		stroke(0,0,0,0);
		fill(255);
		rect(0,HEIGHT-5,WIDTH * _strength / 100, 5);

		// always draw player
		player.draw();

		// draw target spot
		stroke(255);
		fill(255, 255, 255, 0);
		ellipse(mouseX, mouseY, 30);

		debugui();
	}
</script>
</body>